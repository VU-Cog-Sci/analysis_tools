# -*- coding: utf-8 -*-
"""
Created on Wed May  7 16:15:24 2014

@author: Daniel schreij (d.schreij@vu.nl)

This module contains functions to analyze datafiles output by the pupil eyetracker
Currently only datafiles for surfaces can be processed.

The function to start with is analyze_file. This reads in the numpy datafile
generated by the pupil recorder and stores it in a pandas Dataframe. This dataframe
object can then be passed on to most of the other functions to create fixation lists,
heatmaps, etc.

This module can also be executed directly (opposed to importing it). The first 
argument should then be the location of the surface_gaze_positions datafile. For
this datafile, the fixation list is then created.
"""

import os, sys		
import numpy as np
import pandas as pd	
import statsmodels.api as sm
from matplotlib import pyplot as plt

def analyze_file(datafile, sacc_threshold=0.9):
	"""Analyze the supplied datafile generated by the pupil eye tracker

	This function parses the saccades and the fixations from the list of xy coordinates.
	It creates a CDF of all difference scores for x and y separately. 
	
	Difference scores that fall above the threshold (default 90% or 0.9) will be counted as a saccade
	Needless to say (but doing it anyway) difference scores that fall within the 90% are part of a fixation
	Thus: 
	 	the lower the threshold, the more liberal the saccade detection
		the higher the threshold, the more conservative the saccade detection

	Arguments
		datafile (string): path to the pupil surface datafile to be parsed
		
	Returns
		pandas dataframe with:
			- Filename/participant record
			- Trial no.
			- label of surface
			- x on surface (normalized)
			- y on surface (normalized)
			- timestamp of x,y measurement
			- x diff compared to previous trial (hor sacc amplitude) 
			- y diff compared to previous trial (ver sacc amplitude)
			- Saccade (did sample occur after saccade (True/False))
			- fixation indices
		
		Each row in this dataframe corresponds with a sample (which is 24 or
		30 per second depending on the recorder setting)
			
	Raises:
		IOError if file not found or file is not a numpy array
	"""
	
	# Read in datafile. Exit is file not found
	print "Looking for {0}".format(datafile)
	if not os.path.isfile(datafile):
		raise IOError("File not found. Please specify a valid file location")
	
	# Load data into numpy series and create pandas dataframe
	eye_data = np.load(datafile)
	data = pd.DataFrame(eye_data, columns=["surface_label","x","y","timestamp"])
	
	# Parse some extra information from the file path. This sadly isn't included in the datafile itself,
	# so it is absolutely *crucial* to adhere to the pupil folder structure when analyzing data!
	(rest, filename) = os.path.split(datafile)
	(rest, trial_no) = os.path.split(rest)
	participant = os.path.split(rest)[1]
	
	data["subject_nr"] = participant
	data["trial_no"] = int(trial_no)
	# It is nice to set this information as the first two columns, so reindex the dataframe by
	# respecifying the order of columns
	data = data.reindex(columns=["subject_nr","trial_no","surface_label","x","y","timestamp"])	
	
	# Timestamps might be read as strings. Convert to floats
	data["timestamp"] = data["timestamp"].astype(float)
	
	# Subract eye data to calculate difference scores from it
	xy = eye_data[:,1:3].astype(float).T	
	vel_data = np.diff(xy)
	
	# Insert 0 for the first diff values of the array (for which no scores can be calculated)
	vel_data = np.insert(vel_data, 0, 0.0, axis=1)
	
	# Add difference scores to array (for now)	
	data["x_diff"] = pd.Series(vel_data[0,:].T, index=data.index)
	data["y_diff"] = pd.Series(vel_data[1,:].T, index=data.index)
	
	# Calculate speed above which to cound x,y shift as saccade
	x_min_sacc_speed = calculate_min_distance(vel_data[0],sacc_threshold)
	y_min_sacc_speed = calculate_min_distance(vel_data[1],sacc_threshold)
	
	# Get rows at which saccades took place. Increment fixation index value after each saccade
	saccade_rows = (vel_data[0] > x_min_sacc_speed) &  (vel_data[1] > y_min_sacc_speed)
	# Get indices of saccade rows. Add 0 to beginning to take in start of first fixation too
	saccades_idx = data[saccade_rows].index.insert(0,0)
	
	# Store True at rows at which saccade is assumed to have taken place in column "saccade"
	data["saccade"] = saccade_rows	
	
	# Create a new series containing the fixation index values, to be added to the data array
	# The indices of the series correspond to the indices of the saccades in the data array
	# That is: saccade 1 demarkates the end of fixation 1, sacc 2 for fix 2, etc.		
	fixation_indices = pd.Series(data=np.arange(1,len(saccades_idx)+1), index=saccades_idx)	
	data["fixation_index"] = fixation_indices
	
	# At row at which no fixation index was entered the value by default is NaN. Use the
	# handy function bfill and ffill to fill these values with the next occurring saccade index value
	data["fixation_index"].ffill(inplace=True)

	return data
	
def calculate_min_distance(data, threshold):
	""" Determine the minimum difference score to be counted as a saccade
	by calculating a cummulative distribution of the difference scores. The
	cutoff value is determined by the value of threshold. Any value that falls
	in the cdf range above threshold can be counted as a saccade.
	
	Arguments
		data (np.array): Vector with velocity data
		threshold: The cut-off value above which speeds are counted as saccade
		
	Returns
		float: minimum diff value to count as saccade
	"""

	# Remove negative values (convert to positive)	
	vel = np.abs(data)	
	# Create empirical CDF of velocities
	ecdf = sm.distributions.ECDF(vel)
	# Create the 'bins' by interpolating between the min and max values (1000 points)
	bins = np.linspace(min(vel),max(vel),1000)
	# Get the probability value of each bin
	prob = ecdf(bins)
	# The min sacc speed is the value of the first bin that exceeds the threshold
	min_sacc_speed = bins[prob > threshold][0]
	
	return min_sacc_speed
	
def generate_fixations_list(data):
	"""
	Compose a list of fixations from the Dataframe created by @analyze_file
	Additionally calculate the duration of each fixation
	
	Arguments
		data (pandas dataframe): output of analyze_file function 
		
	Returns:
		pandas dataframe with:
			- Filename/participant record
			- Trial no.
			- label of surface
			- x on surface (normalized)
			- y on surface (normalized)
			- timestamp of x,y measurement
			- x diff compared to previous trial (hor sacc amplitude)
			- y diff compared to previous trial (ver sacc amplitude)
			- fixation indices
			- fixation durations
			
		Each row in this dataframe corresponds to a fixation
	
	"""
	# Get indices of saccade rows. Add 0 to beginning to take in start of first fixation too
	saccade_idx = data[data.saccade == True].index.insert(0,0)
	# Extract relevant rows from total dataframe and remove saccade column
	fixations = data.ix[saccade_idx].drop("saccade", axis=1)

	# Calculate duration of each fixation. diff takes next element and subtracts the previous.
	# Thus diff actually gives duration of *previous* fixation (index is 1 to high by default)
	# shift(-1) corrects for this.
	fixation_durations = fixations["timestamp"].diff().shift(-1)	
	fixations["fixation_duration_ms"] = (fixation_durations*1000).round()
	
	#The last fixation duration is NaN with this method and needs to be calculated separately
	fixations["fixation_duration_ms"][fixations.index[-1]] = (data["timestamp"][data.index[-1]] - fixations["timestamp"][fixations.index[-1]]).round()
	return fixations


def generate_heatmap((x,y), bins=25):
	fig,ax = plt.subplots(figsize=(6,6))
	h, x_edge, y_edge = np.histogram2d(x.astype('float'), y.astype('float'), bins=bins)
	extent = [x_edge[0], x_edge[-1], y_edge[0], y_edge[-1]]
	ax.imshow(h,extent=extent,interpolation='gaussian',origin='lower')


if __name__ == "__main__":
	if len(sys.argv)	< 2:
		print "Please supply data file location"
	else:	
		datafile = sys.argv[1]
		try:
			# Get data from numpy file
			eye_data = analyze_file(datafile,0.9)
			
			# Compose a list of fixations
			fixations = generate_fixations_list(eye_data)
			
		except IOError as e:
			print >> sys.stderr, e.message
			sys.exit(1)		
			
		# generate_heatmap((eye_data["x"], eye_data["y"]),25)
		

		
			
		