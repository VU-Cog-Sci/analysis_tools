# -*- coding: utf-8 -*-
"""
Created on Wed May  7 16:15:24 2014

@author: Daniel schreij (d.schreij@vu.nl)

This module contains functions to analyze datafiles output by the pupil eyetracker
Currently only datafiles for surfaces can be processed.

The function to start with is analyze_file. This reads in the numpy datafile
generated by the pupil recorder and stores it in a pandas Dataframe. This dataframe
object can then be passed on to most of the other functions to create fixation lists,
heatmaps, etc.

This module can also be executed directly (opposed to importing it). The first 
argument should then be the location of the surface_gaze_positions datafile. For
this datafile, the fixation list is then created.
"""

import os, sys		
import numpy as np
import pandas as pd	
import statsmodels.api as sm
import matplotlib.pyplot as plt
import scipy.ndimage as ndi

def analyze_file(datafile, sacc_threshold=0.9):
	"""Analyze the supplied datafile generated by the pupil eye tracker

	This function parses the saccades and the fixations from the list of xy coordinates.
	It creates a CDF of all difference scores for x and y separately. 
	
	Difference scores that fall above the threshold (default 90% or 0.9) will be counted as a saccade
	Needless to say (but doing it anyway) difference scores that fall within the 90% are part of a fixation
	Thus: 
	 	- the lower the threshold, the more liberal the saccade detection
		- the higher the threshold, the more conservative the saccade detection

	Parameters
	----------
	datafile: string
		path to the pupil surface datafile to be parsed
	sacc_threshold: float, default 0.9
		Threshold in CDF above which to count diff value as saccade
		
	Returns
	-------
	pandas.Dataframe with:
		- Filename/participant record
		- Trial no.
		- label of surface
		- index of current frame
		- x on surface (normalized)
		- y on surface (normalized)
		- timestamp of x,y measurement
		- x diff compared to previous trial (hor sacc amplitude) 
		- y diff compared to previous trial (ver sacc amplitude)
		- Saccade (did sample occur after saccade (True/False))
		- fixation indices
		
		Each row in this dataframe corresponds with a sample (which is 24 or
		30 per second depending on the recorder setting)
			
	Raises
	------
	IOError if file not found or file is not a numpy array	
	"""
	
	# Read in datafile. Exit is file not found
	print "Analyzing {0}".format(datafile)
	if not os.path.isfile(datafile):
		raise IOError("File not found. Please specify a valid file location")
	
	# Load data into numpy series and create pandas dataframe
	eye_data = np.load(datafile)
	data = pd.DataFrame(eye_data, columns=["frame_index","surface_label","x","y","timestamp"])
	
	# Parse some extra information from the file path. This sadly isn't included in the datafile itself,
	# so it is absolutely *crucial* to adhere to the pupil folder structure when analyzing data!
	(rest, filename) = os.path.split(datafile)
	(rest, trial_no) = os.path.split(rest)
	participant = os.path.split(rest)[1]
	
	data["subject_file"] = participant
	data["trial_no"] = int(trial_no)
	# It is nice to set this information as the first two columns, so reindex the dataframe by
	# respecifying the order of columns
	data = data.reindex(columns=["subject_file","trial_no","surface_label","frame_index", "x","y","timestamp"])	
	data.x = data.x.astype(float)
	data.y = data.y.astype(float)	
	
	# Timestamps might be read as strings. Convert to floats
	data["timestamp"] = data["timestamp"].astype(float)
	
	# Subract eye data to calculate difference scores from it
	xy = eye_data[:,2:4].astype(float).T	
	vel_data = np.diff(xy)
	
	# Insert 0 for the first diff values of the array (for which no scores can be calculated)
	vel_data = np.insert(vel_data, 0, 0.0, axis=1)
	
	# Add difference scores to array (for now)	
	data["x_diff"] = pd.Series(vel_data[0,:].T, index=data.index)
	data["y_diff"] = pd.Series(vel_data[1,:].T, index=data.index)
	
	# Calculate speed above which to cound x,y shift as saccade
	x_min_sacc_speed = calculate_min_distance(vel_data[0],sacc_threshold)
	y_min_sacc_speed = calculate_min_distance(vel_data[1],sacc_threshold)
	
	# Get rows at which saccades took place. Increment fixation index value after each saccade
	saccade_rows = (np.abs(vel_data[0]) > x_min_sacc_speed) | (np.abs(vel_data[1]) > y_min_sacc_speed)
	# Get indices of saccade rows. Add 0 to beginning to take in start of first fixation too
	saccades_idx = data[saccade_rows].index.insert(0,0)
	
	# Store True at rows at which saccade is assumed to have taken place in column "saccade"
	data["saccade"] = saccade_rows	
	
	# Create a new series containing the fixation index values, to be added to the data array
	# The indices of the series correspond to the indices of the saccades in the data array
	# That is: saccade 1 demarkates the end of fixation 1, sacc 2 for fix 2, etc.		
	fixation_indices = pd.Series(data=np.arange(1,len(saccades_idx)+1), index=saccades_idx)	
	data["fixation_index"] = fixation_indices
	
	# At row at which no fixation index was entered the value by default is NaN. Use the
	# handy function bfill and ffill to fill these values with the next occurring saccade index value
	data["fixation_index"].ffill(inplace=True)

	return data
	
def calculate_min_distance(data, threshold):
	""" Determine the minimum difference score to be counted as a saccade
	by calculating a cummulative distribution of the difference scores. The
	cutoff value is determined by the value of threshold. Any value that falls
	in the cdf range above threshold can be counted as a saccade.
	
	Parameters
	----------
	data: (Nx2) np.array 
		Vector with velocity data
		
	threshold: float 
		The cut-off value above which speeds are counted as saccade
		
	Returns
	-------
	float: minimum diff value to count as saccade
	"""

	# Remove negative values (convert to positive)	
	vel = np.abs(data)	
	# Create empirical CDF of velocities
	ecdf = sm.distributions.ECDF(vel)
	# Create the 'bins' by interpolating between the min and max values (1000 points)
	bins = np.linspace(min(vel),max(vel),1000)
	# Get the probability value of each bin
	prob = ecdf(bins)
	# The min sacc speed is the value of the first bin that exceeds the threshold
	min_sacc_speed = bins[prob > threshold][0]
	
	return min_sacc_speed
	
def generate_fixations_list(data, strict=True, keep_fix_index=False):
	"""
	Compose a list of fixations from the Dataframe created by analyze_file(). 
	Additionally calculate the duration of each fixation
	
	Parameters
	----------
	data: pandas.Dataframe
		output of analyze_file function
		
	strict: bool, default True
		Due to the low sampling frequency of the pupil
		eye tracker, it is possible that gaze positions that are mid-saccade are
		incorrectly registered as fixations, which have an exceptionally short latency
		of 30 ms. This options specifies if these errononeous fixations should be
		filtered out. (default: True)
		
	keep_fix_index: bool, default False
		Depends on the value of 'strict'.
		Indicates if the original fixation indices should be kept, or if the filtered 
		saccades should be reindexed.
		
	Returns
	-------
	
	pandas.Dataframe with:
		
		- Filename/participant record
		- Trial no.
		- label of surface
		- x on surface (normalized)
		- y on surface (normalized)
		- timestamp of x,y measurement
		- x diff compared to previous trial (hor sacc amplitude)
		- y diff compared to previous trial (ver sacc amplitude)
		- fixation indices
		- fixation durations
			
		Each row in this dataframe corresponds to a fixation
	
	"""
	# Get indices of saccade rows. Add 0 to beginning to take in start of first fixation too
	saccade_idx = data[data.saccade == True].index.insert(0,0)
	# Extract relevant rows from total dataframe and remove saccade column
	fixations = data.ix[saccade_idx].drop("saccade", axis=1)

	# Calculate duration of each fixation. diff takes next element and subtracts the previous.
	# Thus diff actually gives duration of *previous* fixation (index is 1 to high by default)
	# shift(-1) corrects for this.
	fixation_durations = fixations["timestamp"].diff().shift(-1)	
	fixations["fixation_duration_ms"] = (fixation_durations*1000).round()
	
	#The last fixation duration is NaN with this method and needs to be calculated separately
	fixations["fixation_duration_ms"][fixations.index[-1]] = ((data["timestamp"][data.index[-1]] - fixations["timestamp"][fixations.index[-1]])*1000).round()

	# If strict is true, register only the 'probable' fixations (so no < 2 frames duration)
	if strict:
		fixations = fixations[fixations.fixation_duration_ms > 40]
		# Reindex the remaining saccades		
		if not keep_fix_index:
			fixations.fixation_index = np.arange(1,len(fixations)+1)
	
	
	
	return fixations


def generate_heatmap(eye_data, size=(1000,1200), bins=None):
	"""Generates heatmap of supplied samples
	
	Plots a pyplot.hist2d of the supplied list of samples
	
	Parameters
	----------
	eye_data: pandas.Dataframe
		With at least the x and y columns of the eye data
	size: tuple of ints
		Dimensions of the plot
	bins: int, default None
		Number of bins to divide the hist2d in. If default None is given
		bin size are determined by size of the dataset		
	"""
	
	# IPython uses a different plotting dimension system, which is much smaller
	# than the normal pixel notation.
	try:
		__IPYTHON__ # raises exception if it not exists, otherwise just evaluates to True
		plt.figure(figsize=(size[0]/200, size[1]/200))
	except:
		plt.figure(figsize=size)	
	
	plt.xlim(0,size[0])
	plt.ylim(0,size[1])	
		

	if bins is None:
		bins = len(eye_data)/4
	
	h, x_edge, y_edge = np.histogram2d(eye_data.x*size[0], eye_data.y*size[1], bins=(range(size[0]+1),range(size[1]+1)))
	h = ndi.gaussian_filter(h, (15,15))  ## gaussian convolution
	plt.imshow(h.T)
	
	
def plot_samples(eye_data, size=(1000,1200)):
	# IPython uses a different plotting dimension system, which is much smaller
	# than the normal pixel notation.
	try:
		__IPYTHON__ # raises exception if it not exists, otherwise just evaluates to True
		plt.figure(figsize=(size[0]/200, size[1]/200))
	except:
		plt.figure(figsize=size)	
	
	plt.xlim(0,size[0])
	plt.ylim(0,size[1])	
	
	
	
def plot_fixations(fixations, size=(1000,1200), surface_image=None, annotated=True):
	"""Plots the fixations on a surface specified by size. Saccades are shown by lines
	and fixations by circles at the start and end points of these lines. The longer the
	fixation was at a specific point, the bigger the diameter of the circle at that point.
	
	Parameters
	----------
	fixations: pandas.Dataframe
		This supplied dataframe at least needs to contain the columns:
			
			- x
			- y
			- fixation_index
			- fixation_duration
			
	size: tuple, default (1000,1200)
		The space to plot the fixations in. The fixation coordinates inside a surface are 
		normalized by the pupil eye tracker so dimensions need to be specified to be able
		to plot them.
	surface_image: string, default None:
		Path to the image to use as the background of the fixation plot	

	Raises
	------
	TypeError: if surface_image is not a string to an image
	IOError: if image is not found at specified path	
	"""

	# IPython uses a different plotting dimension system, which is much smaller
	# than the normal pixel notation.
	try:
		__IPYTHON__ # raises exception if it not exists, otherwise just evaluates to True
		plt.figure(figsize=(size[0]/200, size[1]/200))
	except:
		plt.figure(figsize=size)	
	
	plt.xlim(0,size[0])
	plt.ylim(0,size[1])	
	
	# First saccade somehow is almost always logged outside of the surface
	# Discard it if so.
	if (fixations["x"].head(1) < 0)[0] or (fixations["y"].head(1) < 0)[0] or (fixations["x"].head(1) > 1)[0] or (fixations["y"].head(1) > 1)[0]:
		fixations = fixations[fixations.fixation_index != 1]
	
	# First check if image location is specified and exists as a file.
	if not surface_image is None:
		if not type(surface_image) == str:
 			raise TypeError("surface_image must be a path to the image")
		else:
			if not (os.path.isfile(surface_image) and os.access(surface_image, os.R_OK)):
				raise IOError("Image file not found at path or is unreadable (check permissions)")
			else:
				# Flip image upside down
				im = plt.imread(surface_image)
				plt.imshow(im, aspect='auto', extent=[0,size[0], 0, size[1]])
	
	x_coords = list(fixations["x"]*size[0])
	y_coords = list(fixations["y"]*size[1])

	# Plot the lines representing the fixation displacements (i.e. saccades)
	plt.plot(x_coords, y_coords,'b+-')	
	
	# Plot fixations. The longer the fixation the bigger the radius of its circle
	# Use a scalar value to adapt the relative radius to the size of the plot
	scalar = size[0]/1000.0		
	plt.scatter(x=x_coords, y=y_coords, c='r', alpha=0.5, s=scalar*fixations["fixation_duration_ms"], linewidths=1)	
	
	if annotated:
		for i in range(len(x_coords)):
			plt.annotate(i+1, xy=(x_coords[i], y_coords[i]), xytext=(-10,10), textcoords = 'offset points')
	plt.show()
	
	

def analyze_files_in_folder(folder, sacc_threshold=0.9, _sort_result=True):
	"""Travese through folders looking for datafilea generated by the pupil eye tracker

	This function recursively traverses through a folder structure looking for pupil data files.
	A good starting point always is the main folder of the recording session.
	For instance if you perform a recording with pupil, it's data structure 
	commonly is
	
	<pupil_folder>/recordings/<session_name>/XXX
	
	where XXX is a number starting from 000, incrementing with each recording.
	The <session_name> variable will be used for the datafile/participant name
	and the XXX for the trial no.	
	
	Parameters
	----------
	folder: string
		path to the starting folder which to traverse from.
		
	sacc_threshold: float, default 0.9
		distance threshold above which to count an (x,y) as a saccade.
		
	Returns
	-------
	pandas.Dataframe with:
		
		- Filename/participant record
		- Trial no.
		- label of surface
		- index of current frame
		- x on surface (normalized)
		- y on surface (normalized)
		- timestamp of x,y measurement
		- x diff compared to previous trial (hor sacc amplitude) 
		- y diff compared to previous trial (ver sacc amplitude)
		- Saccade (did sample occur after saccade (True/False))
		- fixation indices
		
		Each row in this dataframe corresponds with a sample (which is 24 or
		30 per second depending on the recorder setting)
			
	Raises
	------
	IOError if folder not found.
	
	"""	
	if not os.path.isdir(folder):
		raise IOError("Folder not found!")
		
	folder_contents = os.listdir(folder)
	
	data = None
	fixations = None
	for item in folder_contents:
		# Skip directory specifics
		if item in [".",".."]:
			continue
		
		item_path = os.path.join(folder,item)
		
		# If item is a folder, dive into it and restart this process!
		if os.path.isdir(item_path):
			new_data, new_fixations = analyze_files_in_folder(item_path, sacc_threshold, _sort_result=False)
			if not new_data is None:						
				if not data is None:
					data = pd.concat([data,new_data], ignore_index=True)
				else:			
					data = new_data
					
			if not new_fixations is None:
				if not fixations is None:
					fixations = pd.concat([fixations,new_fixations], ignore_index=True)
				else:
					fixations = new_fixations
						
		# If item is a file, check if is the file we are looking for and analyze
		elif os.path.isfile(item_path) and os.path.split(item_path)[1] == "surface_gaze_positions.npy":
			new_data = analyze_file(item_path, sacc_threshold)
			new_fixations = generate_fixations_list(new_data)
			if not new_data is None:						
				if not data is None:
					data = pd.concat([data,new_data], ignore_index=True)
				else:			
					data = new_data
			if not new_fixations is None:						
				if not fixations is None:
					fixations = pd.concat([fixations, new_fixations], ignore_index=True)
				else:			
					fixations = new_fixations		
								
	# Due to the recursive nature of this function, things might not happen in order
	# or in a sorted ways as one might expect. Therefore, explicitly sort the result afterwards
	# Only do this for the top-level function (so not for the recursive calls)
	if _sort_result:
		if not data is None:
			data = data.sort_index(by=['subject_file','trial_no','timestamp']).reset_index(drop=True)
		if not fixations is None:
			fixations = fixations.sort_index(by=['subject_file','trial_no','timestamp']).reset_index(drop=True)
	
	return data, fixations
	


if __name__ == "__main__":
	if len(sys.argv)	< 2:
		print "Please supply data file location"
	else:	
		datafile = sys.argv[1]
			
		try:
			if os.path.isfile(datafile):					
				# Get data from numpy file
				eye_data = analyze_file(datafile,0.9)
				
				# Compose a list of fixations
				fixations = generate_fixations_list(eye_data)
				
				eye_data.to_csv(os.path.join(os.getcwd(),"raw_data.csv"), index=False)
				fixations.to_csv(os.path.join(os.getcwd(),"fixations.csv"), index=False)
			
			# If a folder is given as argument, traverse it while looking for datafiles
			if os.path.isdir(datafile):		
				eye_data = analyze_files_in_folder(datafile, 0.9)
				
				# Write data to csv file
				eye_data.to_csv(os.path.join(os.getcwd(),"raw_data.csv"), index=False)
		
		except IOError as e:
			print >> sys.stderr, e.message
			sys.exit(1)		
			
		

		
			
		